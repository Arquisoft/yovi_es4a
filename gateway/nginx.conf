# El bloque 'events' configura el comportamiento general de las conexiones de red.
events {
    # Define el número máximo de conexiones simultáneas que puede manejar un solo proceso de trabajo de Nginx.
    # 1024 es un valor estándar que permite manejar un tráfico considerable sin saturar la memoria.
    worker_connections 1024;
}

# El bloque 'http' engloba toda la configuración relacionada con el tráfico web (HTTP/HTTPS).
http {
    # 'mime.types' incluye un diccionario que le dice a Nginx qué tipo de archivo se está enviando 
    # (ej: .html es text/html, .css es text/css). Si no sabe el tipo, usa 'application/octet-stream' por defecto.
    include       mime.types;
    default_type  application/octet-stream;

    # Configuración de logs: Define dónde se guardan los registros de Nginx.
    # access.log: Registra cada petición que recibe el servidor.
    # error.log: Registra fallos, errores de configuración o problemas al conectar con los microservicios.
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # ----------------------------------------------------------------------
    # 1. BLOQUE DE REDIRECCIÓN: De HTTP (inseguro) a HTTPS (seguro)
    # ----------------------------------------------------------------------
    server {
        # Escucha en el puerto 80, que es el puerto por defecto para tráfico HTTP sin cifrar.
        listen 80;
        
        # 'server_name _;' es un comodín. Significa que este bloque atrapará cualquier dominio
        # o IP que apunte a este servidor (ej: localhost, 127.0.0.1, midominio.com).
        server_name _; 
        
        # Toma la petición original y la redirige (código 301 - Redirección permanente) 
        # hacia la misma ruta exacta ($request_uri) pero forzando el esquema 'https://'.
        return 301 https://$host$request_uri;
    }

    # ----------------------------------------------------------------------
    # 2. SERVIDOR PRINCIPAL: Manejo del tráfico seguro (HTTPS)
    # ----------------------------------------------------------------------
    server {
        # Escucha en el puerto 443 (por defecto para HTTPS) y activa el motor SSL.
        listen 443 ssl;
        server_name _; 

        # Rutas a los certificados de seguridad. 
        # El script 'entrypoint.sh' asegura que estos archivos existan antes de que Nginx arranque,
        # ya sean generados automáticamente para localhost o inyectados desde Let's Encrypt en Azure.
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # Opciones de seguridad recomendadas para evitar vulnerabilidades.
        # Desactiva protocolos obsoletos permitiendo solo los modernos y seguros.
        ssl_protocols TLSv1.2 TLSv1.3;
        # Define qué algoritmos de cifrado usar (evita MD5 o algoritmos nulos/débiles).
        ssl_ciphers HIGH:!aNULL:!MD5;
        # Da prioridad a los cifrados elegidos por el servidor frente a los del cliente.
        ssl_prefer_server_ciphers on;

        # ----------------------------------------------------------------------
        # RUTEO DE SERVICIOS (API GATEWAY / PROXY INVERSO)
        # Nginx actúa como un "recepcionista" que dirige las peticiones al contenedor correcto.
        # ----------------------------------------------------------------------

        # A) Frontend (WebApp - React/Vite servido por Nginx interno)
        # Cualquier petición a la ruta raíz ("/") caerá aquí.
        location / {
            # ¡Corregido al puerto 80 basado en tu webapp/Dockerfile!
            proxy_pass http://webapp:80; 
            
            # Cabeceras (headers) para pasar al microservicio los datos reales del usuario (IP, Host original).
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Soporte de WebSockets por si acaso (para recargas u otros servicios front-end)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # B) Microservicio de Usuarios
        # Cualquier petición que empiece por "/api/users/" se enviará a este bloque.
        location /api/users/ {
            # ¡Corregido al puerto 3000 basado en tu docker-compose.yml!
            proxy_pass http://users:3000/; 
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # C) Microservicio de Juego (Gamey en Rust)
        # Cualquier petición que empiece por "/api/gamey/" caerá aquí.
        location /api/gamey/ {
            # ¡Corregido al puerto 4000 basado en tu docker-compose.yml!
            proxy_pass http://gamey:4000/; 
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            
            # ¡CRÍTICO PARA JUEGOS EN TIEMPO REAL!
            # Si tu juego usa WebSockets, las conexiones HTTP normales deben poder "escalar" (Upgrade)
            # a una conexión WebSocket persistente. Estas 3 líneas permiten ese cambio de protocolo.
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
    }
}