# ─────────────────────────────────────────────────────────────────────────────
# Bloque 'events': configura el comportamiento de las conexiones de red a bajo nivel.
# worker_connections indica el número máximo de conexiones simultáneas que puede
# manejar cada proceso worker de Nginx. Con 1024 es suficiente para la mayoría
# de cargas de trabajo moderadas.
# ─────────────────────────────────────────────────────────────────────────────
events {
    worker_connections 1024;
}

# ─────────────────────────────────────────────────────────────────────────────
# Bloque 'http': contiene toda la configuración relacionada con el protocolo HTTP/HTTPS.
# ─────────────────────────────────────────────────────────────────────────────
http {
    # Carga los tipos MIME estándar (html, css, js, imágenes, etc.) para que
    # Nginx envíe el Content-Type correcto en cada respuesta.
    include       mime.types;

    # Tipo por defecto cuando no se puede determinar el MIME del archivo.
    default_type  application/octet-stream;

    # Rutas de los logs de acceso (cada petición) y de errores.
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # ─────────────────────────────────────────────────────────────────────────
    # Mapa para gestionar el upgrade de conexiones HTTP → WebSocket de forma
    # dinámica. Si la cabecera "Upgrade" llega con algún valor (ej. "websocket"),
    # se propaga como "upgrade"; si llega vacía, se cierra la conexión.
    # Esto permite que WebSockets funcionen correctamente a través del proxy.
    # ─────────────────────────────────────────────────────────────────────────
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Servidor HTTP (puerto 80): solo existe para redirigir todo el tráfico
    # a HTTPS mediante un redirect permanente (301).
    # server_name _ actúa como comodín que acepta cualquier nombre de host.
    # ─────────────────────────────────────────────────────────────────────────
    server {
        listen 80;
        server_name _;
        return 301 https://$host$request_uri;
    }

    # ─────────────────────────────────────────────────────────────────────────
    # Servidor HTTPS (puerto 443): gestiona todo el tráfico cifrado y actúa
    # como proxy inverso hacia los distintos microservicios internos.
    # ─────────────────────────────────────────────────────────────────────────
    server {
        listen 443 ssl;
        server_name _;

        # Rutas a los certificados TLS. En desarrollo serán autofirmados
        # (generados por entrypoint.sh); en producción serán los reales.
        ssl_certificate     /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # Solo se permiten versiones modernas y seguras de TLS (1.2 y 1.3).
        # Se excluyen versiones antiguas vulnerables (SSLv3, TLS 1.0, TLS 1.1).
        ssl_protocols TLSv1.2 TLSv1.3;

        # Se usan únicamente cifrados fuertes, descartando los anónimos (aNULL)
        # y los basados en MD5, que son considerados inseguros.
        ssl_ciphers HIGH:!aNULL:!MD5;

        # El servidor impone su lista de cifrados sobre la preferencia del cliente,
        # garantizando que siempre se use el algoritmo más seguro disponible.
        ssl_prefer_server_ciphers on;

        # ─────────────────────────────────────────────────────────────────────
        # A) WebApp (frontend React/Vite)
        # Cualquier ruta que no coincida con /api/** se redirige al contenedor
        # 'webapp' en el puerto 80 (servidor HTTP interno de la SPA).
        #
        # proxy_intercept_errors + error_page 404 =200 /: necesario para SPAs
        # con enrutamiento en el cliente (React Router). Cuando Nginx no encuentra
        # un fichero estático, devuelve el index.html con código 200 para que
        # React Router gestione la ruta en el navegador.
        # ─────────────────────────────────────────────────────────────────────
        location / {
            proxy_pass http://webapp:80;

            # Cabeceras estándar de proxy para que el backend conozca el origen real.
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # HTTP/1.1 es necesario para soporte de WebSockets y keep-alive.
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # Permite interceptar errores del backend para aplicar error_page.
            proxy_intercept_errors on;

            # Si el recurso no existe (404), se sirve el index.html con código 200
            # para que React Router maneje la navegación en el cliente.
            error_page 404 =200 /;
        }

        # ─────────────────────────────────────────────────────────────────────
        # B) Microservicio de Usuarios
        # Las peticiones a /api/users/** se redirigen al servicio 'users' en el
        # puerto 3000. La barra final en proxy_pass hace que Nginx elimine el
        # prefijo "/api/users" antes de reenviar la URL al servicio, de modo que
        # el backend recibe la ruta limpia (ej. /api/users/login → /login).
        # ─────────────────────────────────────────────────────────────────────
        location /api/users/ {
            proxy_pass http://users:3000/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }

        # ─────────────────────────────────────────────────────────────────────
        # C) Microservicio de Juego (Gamey)
        # Las peticiones a /api/game/** se redirigen al servicio 'gamey' en el
        # puerto 4000. Igual que en el caso anterior, la barra final en proxy_pass
        # elimina el prefijo "/api/game" antes de enviar la petición al backend,
        # de modo que Rust/el servicio recibe la ruta esperada
        # (ej. /api/game/v1/game/new → /v1/game/new), evitando errores 404.
        # ─────────────────────────────────────────────────────────────────────
        location /api/game/ {
            proxy_pass http://gamey:4000/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }
}